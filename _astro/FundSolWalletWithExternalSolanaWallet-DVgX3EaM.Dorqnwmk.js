import{d7 as z,dk as at,fb as st,db as it,fm as me,d5 as Ye,d4 as we,eh as xe,de as P,da as D,fn as Ce,dW as Fe,fo as rt,fp as ot,f8 as lt,fq as Ke,fr as ze,fs as ct,ft as ye,e4 as dt,fu as ut,fc as Oe,fv as gt,fw as ft,fx as pt,fy as ht,fz as Me,fA as mt,fB as wt,dm as Ue,f9 as Pe,fC as De,fD as At,fE as $e,dh as yt,d6 as h,fd as Ne,fF as ve,fe as Le,fG as Be,fH as vt}from"./app.Dbs6V_q1.js";import{F as St}from"./CheckCircleIcon.DG4NyxCY.js";import{r as y}from"./index.Crn7-fJZ.js";import{b as Se,m as Tt}from"./ModalHeader-CSfzkWxZ.KQF0IT9H.js";import{c as bt,n as It,s as Et,t as Ot}from"./Layouts-BlFm53ED.DNAcEX9b.js";import{o as Re}from"./ScreenHeader-CHmc4-Lu.CDB8Kfz5.js";import{t as Te}from"./FundWalletMethodHeader-Dujd1j7J.DOTw7rnz.js";import{i as jt}from"./InjectedWalletIcon-DLcYOGDj.CyAbXwSp.js";import{t as Wt}from"./index-Dq_xe9dz.CYFAvuPJ.js";import{t as xt,s as Ct,e as Ft,n as _t}from"./Value-tcJV9e0L.CCQPdIyi.js";import{d as He,f as he,c as Mt,u as Ut,p as Pt,l as pe}from"./useSolanaRpcClient-BTAchFxj.8tytr2RI.js";import{c as Dt}from"./useGetTokenPrice-YObgUU6L.Bdidc-9R.js";import{t as $t}from"./analytics-mkkvFRju.DOXuftJB.js";import{C as fe,e as ke,s as Nt}from"./getFormattedUsdFromLamports-B6EqSEho.C-HCdwKa.js";import{r as Lt}from"./getUsdcMintAddress-DFI1hv05.C_5bLXgZ.js";import{e as Bt}from"./getChainName-DjpPdUSc.c2urPd0g.js";import{n as be}from"./formatters.DtIZsRmK.js";import"./WalletIcon.DW8etFtk.js";import"./LoadingSkeleton-U6-3yFwI.DhgKuR2U.js";import"./useGetSolPrice-DwwjjGbd.Cs3YiPXK.js";const Je=()=>{let{walletProxy:e,client:n}=z();return y.useMemo((()=>({signWithUserSigner:async({message:a,targetAppId:l})=>{if(!e)throw Error("Wallet proxy not initialized");let d=await n.getAccessToken();if(!d)throw Error("User must be authenticated");let{signature:o}=await e.signWithUserSigner({accessToken:d,message:a,targetAppId:l});return{signature:o}}})),[e,n])},Ze=["solana:mainnet","solana:devnet","solana:testnet"];function Rt(e){return st().decode(e)}function J(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var kt=0,$="__private_"+kt+++"__implementation";function U(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Vt=0;function H(e){return"__private_"+Vt+++"_"+e}var Z=H("_address"),q=H("_publicKey"),X=H("_chains"),ee=H("_features"),te=H("_label"),ne=H("_icon");class _e{get address(){return U(this,Z)[Z]}get publicKey(){return U(this,q)[q].slice()}get chains(){return U(this,X)[X].slice()}get features(){return U(this,ee)[ee].slice()}get label(){return U(this,te)[te]}get icon(){return U(this,ne)[ne]}constructor({address:n,publicKey:a,label:l,icon:d}){Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,te,{writable:!0,value:void 0}),Object.defineProperty(this,ne,{writable:!0,value:void 0}),U(this,Z)[Z]=n,U(this,q)[q]=a,U(this,X)[X]=Ze,U(this,te)[te]=l,U(this,ne)[ne]=d,U(this,ee)[ee]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===_e&&Object.freeze(this)}}function s(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Gt=0;function T(e){return"__private_"+Gt+++"_"+e}var F=T("_listeners"),ae=T("_version"),se=T("_name"),ie=T("_icon"),E=T("_injection"),re=T("_isPrivyWallet"),Q=T("_accounts"),oe=T("_on"),Y=T("_emit"),Ie=T("_off"),K=T("_connected"),le=T("_connect"),ce=T("_disconnect"),de=T("_signMessage"),ue=T("_signAndSendTransaction"),ge=T("_signTransaction");function Qt(e,...n){s(this,F)[F][e]?.forEach((a=>a.apply(null,n)))}function Yt(e,n){s(this,F)[F][e]=s(this,F)[F][e]?.filter((a=>n!==a))}function Kt(e,n,a){let l=structuredClone(dt().decode(e)),d=ut(n);return d in l.signatures&&(l.signatures[d]=a),new Uint8Array(Oe().encode(l))}function qe(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:a,recoverEmbeddedWallet:l,openModal:d,privy:o,client:i}=z(),{user:t}=me(),{setModalData:r}=we(),{signWithUserSigner:u}=Je();return{signMessage:({message:c,address:w,options:b})=>new Promise((async(N,O)=>{let p=xe(t,w);if(p?.walletClientType!=="privy")return void O(new P("Wallet is not a Privy wallet",void 0,D.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:A,entropyIdVerifier:S}=Fe(t,p),I=Ce(p),m=he(c).toString("base64");if(m.length<1)return void O(new P("Message must be a non-empty string",void 0,D.INVALID_MESSAGE));let x=async()=>{let f;if(!t)throw Error("User must be authenticated before signing with a Privy wallet");let _=await i.getAccessToken();if(!_)throw Error("User must be authenticated to use their embedded wallet.");let C=n??await a(15e3);if(!C)throw Error("Failed to initialize embedded wallet proxy.");if(!await l({address:p.address}))throw Error("Unable to connect to wallet");if(I){let M=await Ke(o,u,{chain_type:"solana",method:"signMessage",params:{message:m,encoding:"base64"},wallet_id:p.id});if(!M.data||!("signature"in M.data))throw Error("Failed to sign message");f=M.data.signature}else{let{response:M}=await C.rpc({accessToken:_,entropyId:A,entropyIdVerifier:S,chainType:"solana",hdWalletIndex:p.walletIndex??0,requesterAppId:b?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:m}}});f=M.data.signature}return f};if(e({showWalletUIs:b?.uiOptions?.showWalletUIs}))try{let f=await x(),_=new Uint8Array(he(f,"base64"));N({signature:_})}catch(f){O(f)}else r({signMessage:{method:"solana_signMessage",data:m,confirmAndSign:x,onSuccess:f=>{N({signature:new Uint8Array(he(f,"base64"))})},onFailure:f=>{O(f)},uiOptions:b?.uiOptions??{}},connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:p.address,entropyId:A,entropyIdVerifier:S,isUnifiedWallet:I,onCompleteNavigateTo:"SignRequestScreen",onFailure:f=>{O(new P("Failed to connect to wallet",f,D.UNKNOWN_CONNECT_WALLET_ERROR))}}}),d("EmbeddedWalletConnectingScreen")}))}}function Ve(){let{isHeadlessSigning:e,openModal:n}=z(),{setModalData:a}=we(),{signMessage:l}=qe(),{user:d}=me();return{signTransaction:async({transaction:o,options:i,chain:t="solana:mainnet",address:r})=>{async function u(c){let{signature:w}=await l({message:Mt(c),address:r,options:{...i,uiOptions:{...i?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:Kt(c,r,w)}}return e({showWalletUIs:i?.uiOptions?.showWalletUIs})?u(o):new Promise((async(c,w)=>{let b=xe(d,r);if(b?.walletClientType!=="privy")return void w(new P("Wallet is not a Privy wallet",void 0,D.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:N,entropyIdVerifier:O}=Fe(d,b),p=Ce(b);function A(I){return m=>{w(m instanceof P?m:new P("Failed to connect to wallet",m,I))}}let S={account:b,transaction:o,chain:t,signOnly:!0,uiOptions:i?.uiOptions||{},onConfirm:u,onSuccess:c,onFailure:A(D.TRANSACTION_FAILURE)};a({connectWallet:{recoveryMethod:b.recoveryMethod,connectingWalletAddress:b.address,entropyId:N,entropyIdVerifier:O,isUnifiedWallet:p,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:A(D.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:S}),n("EmbeddedWalletConnectingScreen")}))}}}let je=new class extends ct{setImplementation(e){J(this,$)[$]=e}async signMessage(e){return J(this,$)[$].signMessage(e)}async signAndSendTransaction(e){return J(this,$)[$].signAndSendTransaction(e)}async signTransaction(e){return J(this,$)[$].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,$,{writable:!0,value:void 0}),J(this,$)[$]=e}}({signTransaction:ye("signTransaction was not injected"),signAndSendTransaction:ye("signAndSendTransaction was not injected"),signMessage:ye("signMessage was not injected")}),Ge=new class{get version(){return s(this,ae)[ae]}get name(){return s(this,se)[se]}get icon(){return s(this,ie)[ie]}get chains(){return Ze.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:s(this,le)[le]},"standard:disconnect":{version:"1.0.0",disconnect:s(this,ce)[ce]},"standard:events":{version:"1.0.0",on:s(this,oe)[oe]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:s(this,ue)[ue]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:s(this,ge)[ge]},"solana:signMessage":{version:"1.0.0",signMessage:s(this,de)[de]},"privy:":{privy:{signMessage:s(this,E)[E].signMessage,signTransaction:s(this,E)[E].signTransaction,signAndSendTransaction:s(this,E)[E].signAndSendTransaction}}}}get accounts(){return s(this,Q)[Q].slice()}get isPrivyWallet(){return s(this,re)[re]}constructor({name:e,icon:n,version:a,injection:l,wallets:d}){Object.defineProperty(this,Y,{value:Qt}),Object.defineProperty(this,Ie,{value:Yt}),Object.defineProperty(this,F,{writable:!0,value:void 0}),Object.defineProperty(this,ae,{writable:!0,value:void 0}),Object.defineProperty(this,se,{writable:!0,value:void 0}),Object.defineProperty(this,ie,{writable:!0,value:void 0}),Object.defineProperty(this,E,{writable:!0,value:void 0}),Object.defineProperty(this,re,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,oe,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),Object.defineProperty(this,le,{writable:!0,value:void 0}),Object.defineProperty(this,ce,{writable:!0,value:void 0}),Object.defineProperty(this,de,{writable:!0,value:void 0}),Object.defineProperty(this,ue,{writable:!0,value:void 0}),Object.defineProperty(this,ge,{writable:!0,value:void 0}),s(this,F)[F]={},s(this,oe)[oe]=(o,i)=>(s(this,F)[F][o]?.push(i)||(s(this,F)[F][o]=[i]),()=>s(this,Ie)[Ie](o,i)),s(this,K)[K]=o=>{o!=null&&(s(this,Q)[Q]=o.map((({address:i})=>new _e({address:i,publicKey:ze.decode(i)})))),s(this,Y)[Y]("change",{accounts:this.accounts})},s(this,le)[le]=async()=>(s(this,Y)[Y]("change",{accounts:this.accounts}),{accounts:this.accounts}),s(this,ce)[ce]=async()=>{s(this,Y)[Y]("change",{accounts:this.accounts})},s(this,de)[de]=async(...o)=>{let i=[];for(let{account:t,...r}of o){let{signature:u}=await s(this,E)[E].signMessage({...r,address:t.address});i.push({signedMessage:r.message,signature:u})}return i},s(this,ue)[ue]=async(...o)=>{let i=[];for(let t of o){let{signature:r}=await s(this,E)[E].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});i.push({signature:r})}return i},s(this,ge)[ge]=async(...o)=>{let i=[];for(let{transaction:t,account:r,options:u,chain:c}of o){let{signedTransaction:w}=await s(this,E)[E].signTransaction({transaction:t,address:r.address,chain:c||"solana:mainnet",options:u});i.push({signedTransaction:w})}return i},s(this,se)[se]=e,s(this,ie)[ie]=n,s(this,ae)[ae]=a,s(this,E)[E]=l,s(this,Q)[Q]=[],s(this,re)[re]=!0,l.on("accountChanged",s(this,K)[K],this),s(this,K)[K](d)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:je});function zt(){let{ready:e}=it(),{user:n}=me(),{signMessage:a}=qe(),{signTransaction:l}=Ve(),{signAndSendTransaction:d}=(function(){let t=Ye(),{isHeadlessSigning:r,openModal:u,privy:c}=z(),{setModalData:w}=we(),{signTransaction:b}=Ve(),N=He(),{user:O}=me(),{signWithUserSigner:p}=Je();return{signAndSendTransaction:async({transaction:A,address:S,chain:I="solana:mainnet",options:m})=>{let x=xe(O,S);if(x?.walletClientType!=="privy")throw new P("Wallet is not a Privy wallet",void 0,D.EMBEDDED_WALLET_NOT_FOUND);let f=Ce(x);async function _(C){if(m?.sponsor)return await(async v=>{if(!f)throw new P("Sponsoring transactions is only supported for wallets on the TEE stack",D.INVALID_DATA);let j=await Ke(c,p,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:he(v).toString("base64"),encoding:"base64"},caip2:`solana:${(await N(I).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:x.id});if(j.data&&"hash"in j.data)return{signature:ze.decode(j.data.hash)};throw Error("Failed to sign and send transaction")})(C);let{signedTransaction:M}=await b({transaction:C,address:S,chain:I,options:{...m,uiOptions:{...m?.uiOptions,showWalletUIs:!1}}}),{signature:g}=await N(I).sendAndConfirmTransaction(M);return{signature:g}}return r({showWalletUIs:m?.uiOptions?.showWalletUIs})?_(A):new Promise((async(C,M)=>{let g,v,{entropyId:j,entropyIdVerifier:R}=Fe(O,x);function k(G){return W=>{M(W instanceof P?W:new P("Failed to connect to wallet",W,G))}}let L={account:x,transaction:A,chain:I,signOnly:!1,uiOptions:m?.uiOptions||{},onConfirm:_,onSuccess:C,onFailure:k(D.TRANSACTION_FAILURE),isSponsored:!!m?.sponsor},V={recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,entropyId:j,entropyIdVerifier:R,isUnifiedWallet:f,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:k(D.UNKNOWN_CONNECT_WALLET_ERROR)};t.fundingConfig&&(g=rt({address:S,appConfig:t,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...m,asset:"native-currency",chain:I},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),v={amount:t.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:I,destinationAddress:S,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),w({connectWallet:V,standardSignAndSendTransaction:L,funding:g,solanaFundingData:v}),u("EmbeddedWalletConnectingScreen")}))}}})(),o=y.useMemo((()=>{let t=[...ot(n).sort(((u,c)=>(u.walletIndex??0)-(c.walletIndex??0)))],r=lt(n);return r.length?[...t,...r]:t}),[n]),i=y.useMemo((()=>({signMessage:async({message:t,address:r,options:u})=>await a({message:t,address:r,options:u}),signTransaction:async({transaction:t,address:r,chain:u,options:c})=>await l({transaction:t,address:r,chain:u,options:c}),async signAndSendTransaction({transaction:t,address:r,chain:u,options:c}){let{signature:w}=await d({transaction:t,address:r,chain:u,options:c});return{signature:w}}})),[a,l,d]);return y.useEffect((()=>{je?.setImplementation(i)}),[i]),y.useEffect((()=>{var t;!e||(t=Ge.accounts).length===o.length&&t.every(((r,u)=>r.address===o[u]?.address))||je?.emit("accountChanged",o)}),[e,o]),{ready:e,wallet:Ge}}function Ht(){let{client:e}=z(),{ready:n,wallet:a}=zt(),[l,d]=y.useState([]),[o,i]=y.useState([]);return y.useEffect((()=>{let t=[a,...l.filter((c=>c.chainType==="solana"&&!!c.wallet.features)).map((c=>c.wallet))];i(t);let r=l.flatMap((c=>{let w=()=>i([...t]);return c.on("walletsUpdated",w),{connector:c,off:w}})),u=t.map((c=>c.features["standard:events"]?.on("change",(()=>{i([...t])}))));return()=>{u.forEach((c=>c?.())),r.forEach((({connector:c,off:w})=>c.off("walletsUpdated",w)))}}),[l]),y.useEffect((()=>{d(e.connectors?.walletConnectors.filter((r=>r.chainType==="solana"))??[]);let t=()=>{d(e.connectors?.walletConnectors.filter((r=>r.chainType==="solana"))??[])};return e.connectors?.on("connectorInitialized",t),()=>{e.connectors?.off("connectorInitialized",t)}}),[n,e.connectors]),{ready:n,wallets:o}}function Jt(){let{ready:e,wallets:n}=Ht();return{ready:e,wallets:y.useMemo((()=>n.flatMap((a=>a.accounts.map((l=>new at({wallet:a,account:l})))))),[n])}}var Zt="11111111111111111111111111111111";function qt(e){if(!e)throw new Error("Expected a Address.");return typeof e=="object"&&"address"in e?e.address:Array.isArray(e)?e[0]:e}function Xt(e,n){return a=>{if(!a.value)return;const l=a.isWritable?Me.WRITABLE:Me.READONLY;return Object.freeze({address:qt(a.value),role:Qe(a.value)?mt(l):l,...Qe(a.value)?{signer:a.value}:{}})}}function Qe(e){return!!e&&typeof e=="object"&&"address"in e&&wt(e)}var en=2;function tn(){return gt(ft([["discriminator",pt()],["amount",ht()]]),e=>({...e,discriminator:en}))}function nn(e,n){const a=Zt,d={source:{value:e.source??null,isWritable:!0},destination:{value:e.destination??null,isWritable:!0}},o={...e},i=Xt();return Object.freeze({accounts:[i(d.source),i(d.destination)],data:tn().encode(o),programAddress:a})}function an({rows:e}){return h.jsx(xt,{children:e.filter((n=>!!n)).map(((n,a)=>n.value!=null||n.isLoading?h.jsxs(Ct,{children:[h.jsx(Ft,{children:n.label}),h.jsx(_t,{$isLoading:n.isLoading,children:n.value})]},a):null))})}function We(e){return BigInt(Math.floor(1e9*parseFloat(e)))}function Ee(e){return+sn.format(parseFloat(e.toString())/1e9)}let sn=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function rn({tx:e,solanaClient:n,amount:a,asset:l,tokenPrice:d}){if(!e)return null;if(l==="SOL"&&d){let o=We(a),i=fe(o,d),t=await pe({solanaClient:n,tx:e});return{amountInUsd:i,feeInUsd:d?fe(t,d):void 0,totalInUsd:fe(o+t,d)}}if(l==="USDC"&&d){let o="$"+a,i=await pe({solanaClient:n,tx:e}),t=(function(r,u){let c=parseFloat(r.toString())/Nt*u;return c<.01?0:c})(i,d);return{amountInUsd:o,feeInUsd:fe(i,d),totalInUsd:"$"+(parseFloat(a)+t).toFixed(2)}}if(l==="SOL"){let o=We(a),i=await pe({solanaClient:n,tx:e});return{amountInSol:a+" SOL",feeInSol:Ee(i)+" SOL",totalInSol:Ee(o+i)+" SOL"}}return{amountInUsdc:a+" USDC",feeInSol:Ee(await pe({solanaClient:n,tx:e}))+" SOL"}}const jn={component:function(){let e=Ye(),{closePrivyModal:n,createAnalyticsEvent:a}=z(),{data:l,setModalData:d,navigate:o}=we(),{wallets:i}=Jt(),[t,r]=y.useState("preparing"),[u,c]=y.useState(),[w,b]=y.useState(),[N,O]=y.useState();if(!l?.solanaFundingData)throw Error("Funding config is missing");if(!l.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:p,asset:A,chain:S,sourceWalletData:I,destinationAddress:m,afterSuccessScreen:x}=l.solanaFundingData,f=i.find((g=>g.address===I.address&&Ue(I.walletClientType)===Ue(g.standardWallet.name))),_=He()(S),{tokenPrice:C,isTokenPriceLoading:M}=Dt("solana");return y.useEffect((()=>{if(t!=="preparing"||M||!f)return;let g=A==="SOL"?We(p):(function(v){return BigInt(Math.floor(1e6*parseFloat(v)))})(p);b({amount:(A==="SOL"&&C?fe(g,C):p)??p}),(A==="SOL"?(async function({solanaClient:v,source:j,destination:R,amountInLamports:k}){let{value:L}=await v.rpc.getLatestBlockhash().send(),V={address:j},G=Pe($e({version:0}),(W=>Be(V,W)),(W=>Le(L,W)),(W=>ve(nn({amount:k,source:V,destination:R}),W)),(W=>Ne(W)));return new Uint8Array(Oe().encode(G))})({solanaClient:_,source:f.address,destination:m,amountInLamports:g}):(async function({solanaClient:v,source:j,destination:R,amountInBaseUnits:k}){let L=Lt(v.chain),{value:V}=await v.rpc.getLatestBlockhash().send(),G={address:j},[W]=await De({mint:L,owner:j,tokenProgram:ke}),[Ae]=await De({mint:L,owner:R,tokenProgram:ke}),[Xe,et]=await Promise.all([v.rpc.getAccountInfo(W,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch((()=>null)),v.rpc.getAccountInfo(Ae,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch((()=>null))]);if(!Xe?.value)throw Error(`Source token account does not exist for address: ${j}`);let tt=At({payer:G,ata:Ae,owner:R,mint:L}),nt=Pe($e({version:0}),(B=>Be(G,B)),(B=>Le(V,B)),(B=>et?.value?B:ve(tt,B)),(B=>ve(vt({source:W,destination:Ae,authority:G,amount:k}),B)),(B=>Ne(B)));return new Uint8Array(Oe().encode(nt))})({solanaClient:_,source:f.address,destination:m,amountInBaseUnits:g})).then(c).catch((v=>{r("error"),O(v)}))}),[t,p,A,S,f,m,M,C]),y.useEffect((()=>{t==="preparing"&&u&&rn({tx:u,solanaClient:_,amount:p,asset:A,tokenPrice:C}).then((g=>{r("loaded"),b({amount:g?.amountInUsd??g?.amountInUsdc??g?.amountInSol??p,fee:g?.feeInUsd??g?.feeInSol,total:g?.totalInUsd??g?.totalInSol})})).catch((g=>{r("error"),O(g)}))}),[u,p,A,t,C]),y.useEffect((()=>{t==="error"&&N&&(d({errorModalData:{error:N,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:l.solanaFundingData}),o("ErrorScreen",!1))}),[t,o]),y.useEffect((()=>{if(t!=="success")return;let g=setTimeout(x?()=>o(x):n,yt);return()=>clearTimeout(g)}),[t]),h.jsxs(h.Fragment,t==="success"?{children:[h.jsx(Te,{}),h.jsx(bt,{}),h.jsxs(It,{children:[h.jsx(St,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),h.jsx(Re,{title:"Success!",description:`Youâ€™ve successfully added ${p} ${A} to your ${e.name} wallet. It may take a minute before the funds are available to use.`})]}),h.jsx(Et,{}),h.jsx(Se,{})]}:t==="preparing"||t==="loaded"||t==="sending"?{children:[h.jsx(Te,{}),h.jsx(Ot,{style:{marginTop:"16px"},children:h.jsx(jt,{icon:f?.standardWallet.icon,name:f?.standardWallet.name})}),h.jsx(Re,{style:{marginTop:"8px",marginBottom:"12px"},title:t==="sending"&&f?`Confirming with ${f.standardWallet.name}`:"Confirm transaction"}),h.jsx(an,{rows:[{label:"Source",value:be(I.address)},{label:"Destination",value:be(m)},{label:"Network",value:Bt(S)},{label:"Amount",value:w?.amount,isLoading:t==="preparing"},{label:"Estimated fee",value:w?.fee,isLoading:t==="preparing"},{label:"Total",value:w?.total,isLoading:t==="preparing"}]}),h.jsx(Tt,{style:{marginTop:"1rem"},loading:t==="preparing"||t==="sending",onClick:function(){t==="loaded"&&u&&f&&(r("sending"),(async function({transaction:g,chain:v,sourceWallet:j,solanaClient:R}){let{hasFunds:k}=await Ut({solanaClient:R,tx:g});if(!k)throw new P(`Wallet ${be(j.address)} does not have enough funds.`,void 0,D.INSUFFICIENT_BALANCE);let L=Rt((await j.signAndSendTransaction({transaction:g,chain:v}).catch((V=>{throw new P("Transaction was rejected by the user",V,D.TRANSACTION_FAILURE)}))).signature);return await Pt({rpcSubscriptions:R.rpcSubscriptions,signature:L,timeout:2e4}),L})({solanaClient:_,transaction:u,chain:S,sourceWallet:f}).then((g=>{r("success"),a({eventName:$t,payload:{provider:"external",status:"success",txHash:g,address:f.address,value:p,chainType:"solana",clusterName:S,token:A,destinationAddress:m,destinationValue:p,destinationChainType:"solana",destinationClusterName:S,destinationToken:A}})})).catch((g=>{r("error"),O(g)})))},children:"Confirm"}),h.jsx(Se,{})]}:{children:[h.jsx(Te,{}),h.jsx(Wt,{}),h.jsx("div",{style:{marginTop:"1rem"}}),h.jsx(Se,{})]})}};export{jn as FundSolWalletWithExternalSolanaWallet,jn as default};
