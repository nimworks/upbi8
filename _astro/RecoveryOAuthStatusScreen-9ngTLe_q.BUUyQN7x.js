import{dz as H,d4 as B,d7 as K,d8 as de,dS as ne,de as i,da as E,dU as Y,dW as se,dK as ue,dv as he,d6 as o,ef as pe,ej as ve,ek as we,el as ye,em as fe,en as me,eo as ee,ep as Ee}from"./app.Dbs6V_q1.js";import{r as m}from"./index.Crn7-fJZ.js";import{T as _e,m as G,b as Ae}from"./ModalHeader-CSfzkWxZ.KQF0IT9H.js";import{o as X}from"./ScreenHeader-CHmc4-Lu.CDB8Kfz5.js";import{d as ge,e as Ce,o as q}from"./styles-BsotlekN.C9CSHUEw.js";async function J({url:h,popup:c,provider:p}){return c.location=h,new Promise(((l,d)=>{function n(){c?.close(),window.removeEventListener("message",s)}function s(a){a.data&&(a.data.type==="PRIVY_OAUTH_RESPONSE"&&a.data.stateCode&&a.data.authorizationCode&&(l(a.data),n()),a.origin==="https://cdn.apple-cloudkit.com"&&a.data.ckSession&&(l({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:a.data.ckSession}),n()),a.data.type==="PRIVY_OAUTH_ERROR"&&(d(a.data.error),n()))}window.addEventListener("message",s)}))}async function Re({api:h,provider:c,stateCode:p,codeVerifier:l,authorizationCode:d}){if(!d||!p)throw new i("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if(d==="undefined")throw new i("User denied confirmation during OAuth flow");try{return(await h.post(Ee,{authorization_code:d,state_code:p,code_verifier:l,provider:c})).access_token}catch(n){let s=ee(n);throw s.privyErrorCode?new i(s.message||"Invalid code during OAuth flow.",void 0,s.privyErrorCode):s.message==="User denied confirmation during OAuth flow"?new i("Invalid code during oauth flow.",void 0,E.OAUTH_USER_DENIED):new i("Invalid code during OAuth flow.",void 0,E.UNKNOWN_AUTH_ERROR)}}async function Q({api:h,provider:c}){let p=ve(),l=we(),d=await ye(p);try{return c==="icloud"?{url:(await h.post(fe,{client_type:"web"})).url}:{url:(await h.post(me,{redirect_to:window.location.href,code_challenge:d,state_code:l})).url,codeVerifier:p,stateCode:l,provider:c}}catch(n){throw ee(n)}}let Z={"google-drive":{name:"Google Drive",component:Ce},icloud:{name:"iCloud",component:ge}};const Se={component:()=>{let{logout:h}=H(),{navigate:c,setModalData:p,data:l}=B(),{closePrivyModal:d,createAnalyticsEvent:n}=K(),{execute:s}=(()=>{let{client:t,walletProxy:w,refreshSessionAndUser:N}=K(),{data:A}=B(),{user:g}=H(),C=de(),{create:b}=ne();return{execute:async({provider:r,action:le,popup:P,shouldCreateEth:V,shouldCreateSol:L})=>{let R,y;if(!t)throw new i("Missing client");function z(e){if(!e&&t)throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:r}}),new i("Recovery OAuth failed")}switch(r){case"google-drive":{let e,u,{url:x,codeVerifier:O,stateCode:F}=await Q({api:t.api,provider:r});z(x);try{let k=await J({url:x,popup:P,provider:r});if(e=k.stateCode,u=k.authorizationCode,e!==F)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:F??"",returnedStateCode:e??""}}),new i("Unexpected auth flow. This may be a phishing attempt.",void 0,E.OAUTH_UNEXPECTED)}catch(k){throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:k.toString(),provider:r}}),new i("Recovery OAuth failed")}[R,y]=await Promise.all([t.getAccessToken(),Re({api:t.api,provider:r,codeVerifier:O,stateCode:e,authorizationCode:u})]);break}case"icloud":{let{url:e}=await Q({api:t.api,provider:r});z(e);let{ckWebAuthToken:u}=await J({url:e,popup:P,provider:r});y=u,R=await t.getAccessToken()}}if(!w)throw new i("Cannot connect to wallet proxy");if(!R)throw new i("Unable to authorize user");switch(le){case"recover":{let e=A?.recoverWallet?.entropyId,u=A?.recoverWallet?.entropyIdVerifier;if(!e||!u)throw new i("Recovery OAuth failed");t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:e,recoveryMethod:r}}),await w.recover({accessToken:R,entropyId:e,entropyIdVerifier:u,recoveryAccessToken:y}),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:e,recoveryMethod:r}});break}case"create-wallet":{let e;if(t.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),V&&L)e=await b({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g}),e=await b({chainType:"solana",walletIndex:0,latestUser:e.user});else if(L)e=await b({recoveryMethod:r,recoveryAccessToken:y,chainType:"solana",walletIndex:0,latestUser:g});else{if(!V)throw Error("Invalid args to create wallet");e=await b({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g})}if(!e)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:e.account.address}}),C("createWallet","onSuccess",{wallet:e.account});break}case"set-recovery":{let e=Y(g);if(!e)throw C("setWalletRecovery","onError",E.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}});let{entropyId:u,entropyIdVerifier:x}=se(g);await w.setRecovery({accessToken:R,entropyId:u,entropyIdVerifier:x,recoveryMethod:r,recoveryAccessToken:y});let O=Y(await N());if(!O)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}}),C("setWalletRecovery","onSuccess",{method:r,wallet:O});break}default:throw new i("Unsupported recovery action")}}}})(),[a,U]=m.useState(!1),{provider:_,action:f,isInAccountCreateFlow:I,shouldCreateEth:te,shouldCreateSol:re}=l?.recoveryOAuthStatus,[v,M]=m.useState(void 0),[ae,oe]=m.useState(f==="create-wallet");if(_==="user-passcode")throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let W=Z[_].name,$=Z[_].component,D=l?.recoverWallet?.onCompleteNavigateTo,S=new ue((async(t="create-wallet")=>(oe(!0),new Promise(((w,N)=>{setTimeout((async()=>{try{let A=window.open();await s({provider:_,action:t,popup:A,shouldCreateEth:te,shouldCreateSol:re}),U(!0),w()}catch{M({message:`${t==="recover"?"Recovery":"Back up"} with ${W} unsuccessful`,detail:f==="recover"?`Please verify that you are selecting the ${W} account associated with your backup.`:"",retryable:!0}),N()}}),0)})))));m.useEffect((()=>{f!=="recover"&&S.execute(I?"create-wallet":"set-recovery")}),[]),m.useEffect((()=>{if(!a)return;let t=setTimeout((()=>{I?(p({createWallet:{onSuccess:()=>{},onFailure:w=>{n({eventName:"embedded_wallet_creation_failure_logout",payload:{error:w,screen:"RecoveryOAuthScreen"}}),h()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),c("EmbeddedWalletCreatedScreen")):d({shouldCallAuthOnSuccess:!1})}),he);return()=>clearTimeout(t)}),[a]);let j=m.useCallback((async()=>{await S.execute("recover"),D?c(D):U(!0)}),[]),T=_==="google-drive"?"Google Drive":"Apple iCloud",ie=a&&`Successfully ${f==="recover"?"recovered":"backed up"} with ${T}.`||v&&v.message||`${f==="recover"?"Recovering":"Backing up"} with ${T}...`,ce=v?v.detail:"";return o.jsxs(o.Fragment,{children:[o.jsx(_e,{}),ae?o.jsx(o.Fragment,{children:o.jsxs(q,{children:[o.jsx(X,{title:ie,icon:o.jsx($,{style:{width:"38px",height:"38px"}}),description:ce}),v&&v?.retryable?o.jsx(G,{onClick:()=>{pe(),M(void 0),f==="create-wallet"?S.execute("create-wallet"):j()},disabled:!a&&!v?.retryable,children:"Try again"}):null]})}):o.jsxs(q,{children:[o.jsx(X,{title:"Confirm it's really you",icon:o.jsx($,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${T} where your account is backed up.`}),o.jsxs(G,{onClick:j,children:["Confirm with ",T]})]}),o.jsx(Ae,{})]})}};export{Se as RecoveryOAuthScreen,Se as default};
